import{_ as t,o as e,c as o,a as n}from"./chunks/framework.b8a39646.js";const p=JSON.parse('{"title":"Why use Custom Network Data","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"Guides/CustomNetworkData/WhatAndWhy/why.md","filePath":"Guides/CustomNetworkData/WhatAndWhy/why.md"}'),a={name:"Guides/CustomNetworkData/WhatAndWhy/why.md"},s=n('<h1 id="why-use-custom-network-data" tabindex="-1">Why use Custom Network Data <a class="header-anchor" href="#why-use-custom-network-data" aria-label="Permalink to &quot;Why use Custom Network Data&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>There are four main reasons why you might need to use custom network data:</p><ol><li>Custom input state data.</li><li>Custom output state data.</li><li>Removing unused state data.</li><li>Frame zero desync corrections.</li></ol><h2 id="custom-input-state-data" tabindex="-1">Custom Input State Data <a class="header-anchor" href="#custom-input-state-data" aria-label="Permalink to &quot;Custom Input State Data&quot;">​</a></h2><p>Currently the default <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/UCharacterMovementComponent" target="_blank" rel="noreferrer"><strong>CharacterMovementComponent</strong></a> sends an extremely <strong>minimal</strong> input state, and you only really get to customize a few CompressedFlags. This leads to circumstances where you need more <strong>custom data</strong>, but are unable to do so with the <strong>default options</strong>. Maybe you need more CompressedFlags, maybe you need to send extra inputs for things such as joysticks. By using <strong>custom</strong> network data, you are able to expand on the <strong>defaults</strong> and add space for your own data to be sent.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>If you think you need to send <strong>a lot of data</strong> (such as vectors or transforms) in the input state, you are probably thinking about it <strong>wrong</strong>. If you want to send data for a one-off event like starting a slide, where you need to include floats, vectors, do it in a <strong>reliable RPC</strong>.</p></div><h2 id="custom-output-state-data" tabindex="-1">Custom Output State Data <a class="header-anchor" href="#custom-output-state-data" aria-label="Permalink to &quot;Custom Output State Data&quot;">​</a></h2><p>As previously mentioned, the default <strong>client</strong> will send its input state to the <strong>server</strong>, but it will also send its own minimal <strong>output</strong> state of the move. Currently, the client just sends the output location and movement mode, but sometimes this may not be enough. If you had a custom value that was <strong>critical</strong> to performing moves, you might also want to send it as well.</p><p>The <strong>goal</strong> is that the server can use the client&#39;s output state as an additional way to detect if the client is <strong>out of sync</strong>, and isse a <strong>net correction</strong> faster. If the server issues the net correction quick enough, the client will be <strong>smoothly</strong> corrected, meaning the player might not even <strong>notice</strong> the correction.</p><div class="info custom-block"><p class="custom-block-title">NOTE</p><p>The actual difference between the intermediate state and the output state is a bit arbitrary. You can promote the intermediate state to the output state if you think it&#39;s important enough. The main difference is that the output state is what gets send from the clientevery frame, whereas the intermediate state is not.</p></div><h2 id="removing-unused-state-data" tabindex="-1">Removing Unused State Data <a class="header-anchor" href="#removing-unused-state-data" aria-label="Permalink to &quot;Removing Unused State Data&quot;">​</a></h2><p>From more of an <strong>optimization</strong> standpoint, if you look into the <strong>MoveData</strong> being sent, you may notice that some values being sent aren&#39;t actually being used in your game. By not sending those values, you can save a little bit of extra <strong>bandwidth</strong>, or use that bandwidth for more <strong>critical</strong> values.</p><p>A few <strong>common</strong> values that you might not be using are:</p><ol><li>MovementBase information.</li><li>ControlRotation roll (most games only use pitch and yaw).</li><li>Certain CompressedFlags, such as crouch or <strong>engine reserved</strong> flags.</li></ol><h2 id="frame-zero-desync-corrections" tabindex="-1">Frame Zero Desync Corrections <a class="header-anchor" href="#frame-zero-desync-corrections" aria-label="Permalink to &quot;Frame Zero Desync Corrections&quot;">​</a></h2><p>The previously mentioned reasons all targeted sending custom data from the <strong>client</strong> to the <strong>server</strong>, but its also <strong>important</strong> to consider overriding the data being sent from the <strong>server</strong> to the <strong>client</strong>. Frame zero desync correction means that no matter what kind of desync happens, when the client recieves an update from the server, it will recover back to the server&#39;s state in one <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/FClientAdjustment" target="_blank" rel="noreferrer"><strong>ClientAdjustment</strong></a> call. However, if you have added <strong>any</strong> intermediate or output state values, then you will need to send <strong>custom MoveResponse</strong> data to achieve frame zero desync correction.</p><p><strong>To see why, imagine this example:</strong></p><p>You&#39;ve added an <strong>enum</strong> indicating the walk type (slow, normal, sprint) to the <strong>intermediate</strong> state values. If the client gets a <strong>desync</strong>, and this state is not in sync with the server, we will get a correction from the server containing info with the <strong>correct</strong> MoveData, but not anything about the walk type. Then the client will <strong>re-simulate</strong> these moves, but with the <strong>incorrect</strong> walk type again. This will cause the server to send more <strong>net corrections</strong>, until the client ends up <strong>completely</strong> out of sync.</p><p>But by sending all intermediate and output states to the client and achieving frame zero desync correction, even if every state on the client got <strong>horribly</strong> out of sync, it would all be brought back into sync in just <strong>one</strong> net correction!</p>',20),r=[s];function i(u,l,c,h,d,g){return e(),o("div",null,r)}const y=t(a,[["render",i]]);export{p as __pageData,y as default};
