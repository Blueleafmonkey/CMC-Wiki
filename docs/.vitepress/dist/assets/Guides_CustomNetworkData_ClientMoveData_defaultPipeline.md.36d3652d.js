import{_ as s,o as n,c as e,a}from"./chunks/framework.b8a39646.js";const g=JSON.parse('{"title":"Default CharacterMovementComponent Pipeline","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"Guides/CustomNetworkData/ClientMoveData/defaultPipeline.md","filePath":"Guides/CustomNetworkData/ClientMoveData/defaultPipeline.md"}'),o={name:"Guides/CustomNetworkData/ClientMoveData/defaultPipeline.md"},t=a(`<h1 id="default-charactermovementcomponent-pipeline" tabindex="-1">Default CharacterMovementComponent Pipeline <a class="header-anchor" href="#default-charactermovementcomponent-pipeline" aria-label="Permalink to &quot;Default CharacterMovementComponent Pipeline&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Before adding our <strong>custom</strong> data, we need to <strong>learn</strong> a few things about how the default <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/UCharacterMovementComponent" target="_blank" rel="noreferrer"><strong>CharacterMovementComponent</strong></a> works.</p><p>During the <strong>client</strong> CharacterMovementComponent&#39;s <strong>TickComponent</strong>, the function <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/UCharacterMovementComponent/ReplicateMoveToS-" target="_blank" rel="noreferrer"><strong>ReplicateMoveToServer</strong></a> is called. This function does these three things in order:</p><ol><li>Creates and sets a new <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/FSavedMove_Character/" target="_blank" rel="noreferrer"><strong>SavedMove</strong></a>.</li><li>Performs the move using the function, <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/UCharacterMovementComponent/PerformMovement/" target="_blank" rel="noreferrer"><strong>PerformMovement</strong></a>.</li><li>Calls the function, <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/UCharacterMovementComponent/CallServerMovePacked/" target="_blank" rel="noreferrer"><strong>CallServerMovePacked</strong></a>.</li></ol><p>However, this last step is not that simple. If you have watched <a href="https://www.youtube.com/watch?v=urkLwpnAjO0&amp;list=PLXJlkahwiwPmeABEhjwIALvxRSZkzoQpk" target="_blank" rel="noreferrer"><strong>Delgoodie&#39;s CMC tutorials</strong></a>, you would remember that when you added custom variables to the <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/FSavedMove_Character/" target="_blank" rel="noreferrer"><strong>SavedMove</strong></a> struct, you also had to update the <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/FSavedMove_Character/CanCombineWith/" target="_blank" rel="noreferrer"><strong>CanCombineWith</strong></a> function.</p><p>This function checks to see if it can <strong>combine</strong> the current NewMove with the last SavedMove (reffered to as the <strong>PendingMove</strong>). This is because the client doesn&#39;t actualy run CallServerMovePacked <strong>every</strong> frame, but it actually runs it every <strong>other</strong> frame. In the first frame, it actually just <strong>saves</strong> the SavedMove as the PendingMove, and then in the <strong>next</strong> frame it checks to see if it can <strong>combine</strong> the PendingMove with the NewMove. If it can, then it just sends one SavedMove for <strong>both</strong> frames, instead of sending two, which <strong>improves</strong> bandwidth usage.</p><div class="info custom-block"><p class="custom-block-title">NOTE</p><p>You hsould only combine moves if they have basically all the same input state data.</p></div><p>A good example of this happening is if the player was just running in a <strong>straight</strong> line. If the <strong>acceleration</strong> in both frames is pretty much the same, and the <strong>velocity</strong> also doesn&#39;t change much, then it can <strong>combine</strong> the moves and send them as one combined move to the server. The combined move uses the <strong>output</strong> state of the most <strong>recent</strong> SavedMove, but it <strong>adds</strong> the deltaTimes of both moves, so that it is effectively one big move.</p><p>However, if the client was <strong>wrong</strong>, and the moves were <strong>different</strong> (say the player pressed jump in the newest SavedMove, but wasn&#39;t in the PendingMove), then it needs to send <strong>both</strong> moves, <strong>seperately</strong>, but in the same frame.</p><p>You can see how this system works really well, as in <strong>most</strong> 60fps games, the player is <strong>usually</strong> holding down the same keys for a <strong>majority</strong> of the frames, and only <strong>changes</strong> the button states every few seconds.</p><p>But, there is actually one more move that the client will send to the server, called the <strong>OldMove</strong>. The OldMove is the oldest <strong>unacknowledged</strong> important SavedMove. Remember how the server sends back an <strong>acknowledgement</strong> for every move? Sometimes moves get <strong>dropped</strong>, arrive late, or sometimes responses from the server get dropped. To try and combat this, the client will send the <strong>oldest</strong> move that hasn&#39;t been acknowledged by the server, assuming that it was probably dropped out the <strong>first time</strong> it was sent.</p><p>So in total, in any given frame there can be up to <strong>three</strong> different moves being sent; The <strong>NewMove</strong>, <strong>PendingMove</strong>, and the <strong>OldMove</strong>. But there could also be <strong>no moves</strong> being sent, if there aren&#39;t any <strong>unacknowledged</strong> SavedMoves, and we are holding off on sending the move by putting it in the PendingMove for the <strong>next</strong> frame.</p><h2 id="inside-callservermovepacked" tabindex="-1">Inside CallServerMovePacked <a class="header-anchor" href="#inside-callservermovepacked" aria-label="Permalink to &quot;Inside CallServerMovePacked&quot;">​</a></h2><p>After learning all that, we can <strong>finally</strong> start looking inside the function, and exploring what <strong>actually happens</strong> in <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/UCharacterMovementComponent/CallServerMovePacked/" target="_blank" rel="noreferrer"><strong>CallServerMovePacked</strong></a>.</p><p>Firstly, we can see that the <strong>function</strong> takes in 3 variables: <strong>NewMove</strong>, <strong>PendingMove</strong>, and <strong>OldMove</strong>, which we just learnt about in the previous section.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">virtual</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CallServerMovePacked</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FSavedMove_Character</span><span style="color:#C792EA;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">NewMove</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FSavedMove_Character</span><span style="color:#C792EA;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">PendingMove</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FSavedMove_Character</span><span style="color:#C792EA;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">OldMove</span></span>
<span class="line"><span style="color:#89DDFF;">);</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>It is <strong>greatly encouraged</strong> for everyone to go ahead and <strong>read</strong> through this function in the source code <strong>themselves</strong>, as it is only 49 lines long, and can help with <strong>understanding</strong> it better.</p></div><h3 id="filling-the-movedatacontainer" tabindex="-1">Filling the MoveDataContainer <a class="header-anchor" href="#filling-the-movedatacontainer" aria-label="Permalink to &quot;Filling the MoveDataContainer&quot;">​</a></h3><p>Now, inside of the function we first get a <strong>reference</strong> to something called a <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/FCharacterNetworkMoveDataContain-/" target="_blank" rel="noreferrer"><strong>FCharacterNetworkMoveDataContainer</strong></a>, and use the its <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/FCharacterNetworkMoveDataContain-/ClientFillNetwor-/" target="_blank" rel="noreferrer"><strong>ClientFillNetworkMoveData</strong></a> method to fill it with the client data, which contains all 3 moves previously talked about.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Get storage container we&#39;ll be using and fill it with movement data</span></span>
<span class="line"><span style="color:#A6ACCD;">FCharacterNetworkMoveDataContainer</span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;"> MoveDataContainer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">GetNetworkMoveDataContainer</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">MoveDataContainer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">ClientFillNetworkMoveData</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">NewMove</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> PendingMove</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> OldMove</span><span style="color:#89DDFF;">);</span></span></code></pre></div><p>This <strong>FCharacterNetworkDataContainer</strong>, or <strong>MoveDataContainer</strong> for short, is a <strong>struct</strong> which contains three network moves. These <strong>network</strong> moves are not SavedMoves, but another struct called <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/FCharacterNetworkMoveData/" target="_blank" rel="noreferrer"><strong>FCharacterNetworkMoveData</strong></a>, or <strong>NetworkMove</strong> for short. In <strong>ClientFillNetworkMoveData</strong>, we pass along the SavedMoves to the three NetworkMoves to fill them with data, these are then the actual network move structs which are put into the <strong>MoveDataContainer</strong>.</p><p>This can be seen here, where the NewMoveData is a NetworkMove variable.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">NewMoveData</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#82AAFF;">ClientFillNetworkMoveData</span><span style="color:#89DDFF;">(*</span><span style="color:#A6ACCD;">ClientNewMove</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FCharacterNetworkMoveData</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">ENetworkMoveType</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">NewMove</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">bDisableCombinedScopedMove </span><span style="color:#89DDFF;">|=</span><span style="color:#A6ACCD;"> ClientNewMove</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">bForceNoCombine</span><span style="color:#89DDFF;">;</span></span></code></pre></div><details class="details custom-block"><summary>Details</summary><p>This is also <strong>repeated</strong> for the <strong>PendingMoveData</strong>, and the <strong>OldMoveData</strong>. You can see this on the <strong>highlighted</strong> lines of the function:</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FCharacterNetworkMoveDataContainer</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">ClientFillNetworkMoveData</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FSavedMove_Character</span><span style="color:#C792EA;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">ClientNewMove</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FSavedMove_Character</span><span style="color:#C792EA;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">ClientPendingMove</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FSavedMove_Character</span><span style="color:#C792EA;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">ClientOldMove</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	bDisableCombinedScopedMove </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">ensure</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ClientNewMove</span><span style="color:#89DDFF;">))</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">NewMoveData</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#82AAFF;">ClientFillNetworkMoveData</span><span style="color:#89DDFF;">(*</span><span style="color:#F07178;">ClientNewMove</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">FCharacterNetworkMoveData</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">ENetworkMoveType</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">NewMove</span><span style="color:#89DDFF;">);</span></span>
<span class="line highlighted"><span style="color:#F07178;">		bDisableCombinedScopedMove </span><span style="color:#89DDFF;">|=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ClientNewMove</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">bForceNoCombine</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">	bHasPendingMove </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ClientPendingMove </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">nullptr);</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">bHasPendingMove</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">PendingMoveData</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#82AAFF;">ClientFillNetworkMoveData</span><span style="color:#89DDFF;">(*</span><span style="color:#F07178;">ClientPendingMove</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">FCharacterNetworkMoveData</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">ENetworkMoveType</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">PendingMove</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#F07178;">		bIsDualHybridRootMotionMove </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ClientPendingMove</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">RootMotionMontage</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">nullptr)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F07178;">ClientNewMove </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ClientNewMove</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">RootMotionMontage</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">nullptr);</span></span>
<span class="line highlighted"><span style="color:#F07178;">		bDisableCombinedScopedMove </span><span style="color:#89DDFF;">|=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ClientPendingMove</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#A6ACCD;">bForceNoCombine</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">else</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">		bIsDualHybridRootMotionMove </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">false;</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span></span>
<span class="line"><span style="color:#A6ACCD;">	bHasOldMove </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">ClientOldMove </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">nullptr);</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">bHasOldMove</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">OldMoveData</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#82AAFF;">ClientFillNetworkMoveData</span><span style="color:#89DDFF;">(*</span><span style="color:#F07178;">ClientOldMove</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">FCharacterNetworkMoveData</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">ENetworkMoveType</span><span style="color:#89DDFF;">::</span><span style="color:#F07178;">OldMove</span><span style="color:#89DDFF;">);</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></details><div class="info custom-block"><p class="custom-block-title">NOTE</p><p>It might look a little bit confusing, but the <strong>ClientFillNetworkMoveData</strong> method being called on the <strong>NewMoveData</strong> is not the same function as the <strong>ClientFillNetworkMoveData</strong> being called on the <strong>MoveDataContainer</strong>.</p></div><p>Then, in the <strong>NetworkMove</strong>&#39;s <strong>ClientFillNetworkData</strong> method, we only take the <strong>neccessary</strong> data from the SavedMove, and use it to <strong>fill</strong> the NetworkMove</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">NetworkMoveType </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> MoveType</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">TimeStamp </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ClientMove</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">TimeStamp</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">ControlRotation </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ClientMove</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SavedControlRotation</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">CompressedMoveFlags </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ClientMove</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">GetCompressedFlags</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">MovementMode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ClientMove</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">EndPackedMovementMode</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>Just as a quick <strong>summary</strong>, lets go over what we have just looked at. First, we call <strong>ClientFillNetworkMoveData</strong> on the <strong>MoveDataContainer</strong>, and pass in our <strong>NewMove</strong>, <strong>PendingMove</strong>, and <strong>OldMove</strong>. Then, it calls <strong>ClientFillNetworkData</strong> (different from the one we called on the MoveDataContainer) on each of the moves we passed in, and stores only the <strong>necessary</strong> data in the new <strong>NetworkMove</strong> variables; <strong>NewMoveData</strong>, <strong>PendingMoveData</strong>, and <strong>OldMoveData</strong>. Then those <strong>NetworkMove</strong> variables are passed into the <strong>MoveDataContainer</strong>.</p><h3 id="serialising-the-moves" tabindex="-1">Serialising the moves <a class="header-anchor" href="#serialising-the-moves" aria-label="Permalink to &quot;Serialising the moves&quot;">​</a></h3><p>Up until now we&#39;ve just been <strong>passing</strong> around the data, but now we finally have to <strong>serialize</strong> it. If you aren&#39;t familiar with serializing, it just means <strong>converting</strong> all the data to raw <strong>bits</strong>. This <strong>serialization</strong> is done for two reasons:</p><ol><li>Serializing our <strong>NetworkMove</strong> means we can <strong>optimize</strong> it and only send as <strong>few</strong> bits as possible.</li><li>We can serialize a <strong>variable</strong> number of bits, meaning you can add more bits for your <strong>custom data</strong>.</li></ol><div class="info custom-block"><p class="custom-block-title">NOTE</p><p>This was <strong>not</strong> <strong>possible</strong> until recent versions of Unreal Engine (just before Unreal Engine 5 released).</p></div><p>Now that we have a full <strong>MoveDataContainer</strong>, we can begin <strong>serializing</strong> the data. This is simply done by using the <strong>MoveDataContainer</strong>&#39;s <a href="https://docs.unrealengine.com/5.2/en-US/API/Runtime/Engine/GameFramework/FCharacterNetworkMoveDataContain-/Serialize/" target="_blank" rel="noreferrer"><strong>Serialize</strong></a> method.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">MoveDataContainer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Serialize</span><span style="color:#89DDFF;">(*this,</span><span style="color:#A6ACCD;"> ServerMoveBitWriter</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> ServerMoveBitWriter</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">PackageMap</span><span style="color:#89DDFF;">)</span></span></code></pre></div><p>Inside of the <strong>MoveDataContainer</strong>&#39;s <strong>Serialize</strong> method, we can see that all it really does is just call the <strong>Serialize</strong> methods on our three <strong>NetworkMoves</strong>.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#A6ACCD;">NewMoveData</span><span style="color:#89DDFF;">-&gt;</span><span style="color:#82AAFF;">Serialize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">CharacterMovement</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Ar</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> PackageMap</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FCharacterNetworkMoveData</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">ENetworkMoveType</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">NewMove</span><span style="color:#89DDFF;">))</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">false;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>But how do we <strong>actually</strong> serialize? With an <strong>archive</strong>. An archive is a <strong>bitstream</strong> that allows you to “push” bits <strong>onto</strong> or <strong>off of</strong> it. If you haven’t seen a bitstream, don’t worry since you don’t really need to know how it <strong>works</strong>, just how to <strong>use</strong> it. In our case, the archive is <strong>ServerMoveBitWriter</strong>. So let’s see what happens when we call <strong>Serialize</strong> on our <strong>NetworkMoves</strong>.</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">bool</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FCharacterNetworkMoveData</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">Serialize</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">UCharacterMovementComponent</span><span style="color:#C792EA;">&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">CharacterMovement</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FArchive</span><span style="color:#C792EA;">&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">Ar</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UPackageMap</span><span style="color:#C792EA;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">PackageMap</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">FCharacterNetworkMoveData</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">ENetworkMoveType</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">MoveType</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	NetworkMoveType </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> MoveType</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#C792EA;">bool</span><span style="color:#A6ACCD;"> bLocalSuccess </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true;</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">bool</span><span style="color:#A6ACCD;"> bIsSaving </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Ar</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">IsSaving</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">	Ar </span><span style="color:#89DDFF;">&lt;&lt;</span><span style="color:#A6ACCD;"> TimeStamp</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">	// TODO: better packing with single bit per component indicating zero/non-zero</span></span>
<span class="line"><span style="color:#A6ACCD;">	Acceleration</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">NetSerialize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Ar</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> PackageMap</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> bLocalSuccess</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">	Location</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">NetSerialize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Ar</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> PackageMap</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> bLocalSuccess</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">	// ControlRotation : FRotator handles each component zero/non-zero test; it uses a single signal bit for zero/non-zero, and uses 16 bits per component if non-zero.</span></span>
<span class="line"><span style="color:#A6ACCD;">	ControlRotation</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">NetSerialize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Ar</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> PackageMap</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> bLocalSuccess</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#82AAFF;">SerializeOptionalValue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">uint8</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#A6ACCD;">bIsSaving</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Ar</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> CompressedMoveFlags</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">		</span><span style="color:#82AAFF;">SerializeOptionalValue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">UPrimitiveComponent</span><span style="color:#89DDFF;">*&gt;(</span><span style="color:#A6ACCD;">bIsSaving</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Ar</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> MovementBase</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">nullptr);</span></span>
<span class="line"><span style="color:#A6ACCD;">		</span><span style="color:#82AAFF;">SerializeOptionalValue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">FName</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#A6ACCD;">bIsSaving</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Ar</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> MovementBaseBoneName</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> NAME_None</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">		</span><span style="color:#82AAFF;">SerializeOptionalValue</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">uint8</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#A6ACCD;">bIsSaving</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Ar</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> MovementMode</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> MOVE_Walking</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">Ar</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">IsError</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>Here you can see in only a few lines all of what the CMC is sending from client to server. Pay attention to this carefully since this is where we actually control what data is being sent to the server. The Ar is the FArchive object, and we can add data to it in several showcased ways. At the top, the TimeStamp is pushed onto the archive using the &lt;&lt; operator, this just means that the entire 4 byte float is added to the bits. Then we see some helper functions on the Acceleration, Location, and ControlRotation variables which are adding themselves to the Archive under the hood. Note that the Location variable is a FVector_NetQuantized100 and the Acceleration variable is a FVector_NetQuantized10, ControlRotation is just an FRotator. We also have another helper function: SerializeOptionalValue(), which allows us to optionally serialize a value based on a bool. There is one more very helpful way to add bits to the bitstream:</p>`,40),l=[t];function r(p,c,i,D,y,F){return n(),e("div",null,l)}const h=s(o,[["render",r]]);export{g as __pageData,h as default};
