import{_ as e,o as a,c as s,a as n}from"./chunks/framework.b8a39646.js";const b=JSON.parse('{"title":"Networked Booleans in Unreal Engine","description":"","frontmatter":{},"headers":[],"relativePath":"networked-bools.md","filePath":"networked-bools.md"}'),o={name:"networked-bools.md"},t=n(`<h1 id="networked-booleans-in-unreal-engine" tabindex="-1">Networked Booleans in Unreal Engine <a class="header-anchor" href="#networked-booleans-in-unreal-engine" aria-label="Permalink to &quot;Networked Booleans in Unreal Engine&quot;">​</a></h1><p>This page will discuss how Unreal Engine handles networked booleans in its Character Movement Component</p><h2 id="booleans-inside-fsavedmove-character-class" tabindex="-1">Booleans inside FSavedMove_Character class <a class="header-anchor" href="#booleans-inside-fsavedmove-character-class" aria-label="Permalink to &quot;Booleans inside FSavedMove_Character class&quot;">​</a></h2><p>Inside of the FSavedMove_Character class (located inside CharacterMovementComponent.h) we see that they used</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">uint32 variable</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>instead of</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">bool</span><span style="color:#A6ACCD;"> variable</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>This is shown with these variables:</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">uint32 bPressedJump:</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">uint32 bWantsToCrouch:</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">uint32 bForceMaxAccel:</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">uint32 bForceNoCombine:</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">uint32 bOldTimeStampBeforeReset:</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">uint32 bWasJumping:</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>The reason why they use uint32 for boolean values instead of bool, is because bool variables take up at least 1 Byte each, whereas a uint32 only takes up 4 Bytes each. Now you may think, &quot;aren&#39;t they using more bytes then? since each uint32 is 4 bytes, and they are all seperate variables?&quot; Well, this is where bit-fielding comes in. Because each variable only takes up one bit of the 4 bytes that make up a uint32, the variables are automatically compressed into one uint32, meaning that instead of having 6 seperate utin32 or bool variables, it only uses one uint32. Comparing this to using bools, instead of all those variables taking up 6 bytes, they only take up 4 bytes all together, which is pretty neat if you&#39;re sending this information over a network.</p>`,10),l=[t];function i(p,r,c,h,d,u){return a(),s("div",null,l)}const C=e(o,[["render",i]]);export{b as __pageData,C as default};
